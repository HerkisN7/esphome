
substitutions:
  # https://microsoft.github.io/devicescript/devices/esp32/esp32c3-supermini
  board: lolin_c3_mini
  # board: esp32-c3-devkitm-1
  # STEP
  step_pin: GPIO07
  # DIR
  dir_pin: GPIO06
  # Enable TMC2209
  en_pin: GPIO05
  # Diag - Stallguard
  diag_pin: GPIO10
  # RXD
  rx_pin: GPIO20
  # TXD
  tx_pin: GPIO21
  # Staus LED - OK for supermini
  led_pin: GPIO08

  # TMC parameters
  acceleration: 200 steps/s^2
  velocity: 500 steps/s # 200 (motor steps) * ${microsteps}
  microsteps: "0"
  current: 900ma
  stall_threshold: "20"
  tcool_threshold: "100"
  change_direction: "False"
  tmc_address: "0x00"
  sense_resistor: "0.11"

external_components:
  - source:
      type: git
      url: https://github.com/HerkisN7/esphome
      ref: stepper-tmc2209-new_uart
    components: [uart, tmc2209]
#  - source:
#      type: local
#      path: ext_components
#    components: [uart, tmc2209]

#  - source: github://lumascet/esphome@stepper-tmc2209-new_uart
#    components: [uart, tmc2209] 
  


esphome:
  name: test-esp32c3-tmc2209
  friendly_name: Test ESP32C3 TMC2209
  platformio_options: 
    # board_build.flash_mode: dio
     board_build.extra_flags:
      - "-DARDUINO_USB_CDC_ON_BOOT=0"

  on_boot:
    - tmc2209.setup:
          id: stepper1
          microsteps: !lambda |-
            return id(set_microsteps).state;          
          tcool_threshold: !lambda |-
            return id(set_tcool).state;
          current: !lambda |-
            return id(set_current).state;
          stall_threshold: !lambda |-
            return id(set_stall).state;
          sense_resistor: ${sense_resistor}
          uart_address: ${tmc_address}

 
esp32:
  board: ${board}
  framework:
    type: arduino
 

wifi:
  networks:
  - ssid: !secret wifi_ssid
    password: !secret wifi_password
  
logger:
  baud_rate: 0

ota:
  password: ""

web_server:
  port: 80

uart:
  id: uart_stepper
  tx_pin: ${tx_pin}
  rx_pin: ${rx_pin}
  baud_rate: 115200

status_led:
  pin: ${led_pin}

# api:
#  encryption:
#    key: ""
#  reboot_timeout: 0s

interval:
  - interval: 10s
    then:
      - if:
          condition:
      # Stepper freewheel
            - switch.is_off: en_stepper
          then:
            - component.update: position

stepper:
  - platform: tmc2209
    steppers:
    - id: stepper1
      step_pin: ${step_pin}
      dir_pin:
        number: ${dir_pin}
        inverted: ${change_direction}
#      sleep_pin:
#        number: GPIO09
#        inverted: true
      acceleration: ${acceleration}
      deceleration: ${acceleration}
      max_speed: ${velocity}
      sense_resistor: ${sense_resistor}
      uart_address: ${tmc_address}

number:
  - platform: template
    name: Set microsteps
    id: set_microsteps
    mode: box
    min_value: 0
    max_value: 256
    step: 2
    optimistic: true
    restore_value: True
    initial_value: 0
  - platform: template
    name: Set current
    id: set_current
    mode: box
    min_value: 0
    max_value: 1600
    step: 20
    optimistic: true
    restore_value: True
    initial_value: 900
  - platform: template
    name: Set tcool
    id: set_tcool
    mode: box
    min_value: 0
    max_value: 65535
    step: 1
    optimistic: true
    restore_value: True
    initial_value: 200
  - platform: template
    name: Set stall
    id: set_stall
    mode: box
    min_value: 0
    max_value: 255
    step: 1
    optimistic: true
    restore_value: True
    initial_value: 20
  - platform: template
    name: Set target
    id: set_target
    min_value: -10000
    max_value: 10000
    step: 1
    optimistic: true
    restore_value: True
    initial_value: 0
  - platform: template
    name: Set velocity
    id: set_velocity
    mode: box
    min_value: 0
    max_value: 5000
    step: 50
    optimistic: true
    restore_value: True
    initial_value: 1000
    on_value:
      then:
        - stepper.set_speed:
            id: stepper1
            speed: !lambda |-
              return id(set_velocity).state;


script:
  - id: init_stepper
    mode: single
    then:
      - tmc2209.setup:
          id: stepper1
          microsteps: !lambda |-
            return id(set_microsteps).state;          
          tcool_threshold: !lambda |-
            return id(set_tcool).state;
          current: !lambda |-
            return id(set_current).state;
          stall_threshold: !lambda |-
            return id(set_stall).state;
          sense_resistor: ${sense_resistor}
          uart_address: ${tmc_address}


switch:
  - platform: template
    name: Stepper Enable
    id: en_stepper
    optimistic: true
    on_turn_on:
      - switch.turn_on: en_tmc2209
    on_turn_off:
      - switch.turn_off: en_tmc2209

  - platform: gpio
    id: en_tmc2209
    pin:
      number: ${en_pin}
      inverted: true

button:
  - platform: template
    name: Stepper GoTo
    on_press:
      then:
        - lambda: |-          
            id(en_stepper).publish_state(true);
        - script.execute: init_stepper
        - script.wait: init_stepper
        - delay: 200ms
        - lambda: |-          
            id(position).publish_state(id(stepper1).current_position);
        - stepper.set_speed:
            id: stepper1
            speed: !lambda |-
              return id(set_velocity).state;
        - stepper.set_target:
            id: stepper1
            target: !lambda |-
              return id(set_target).state;
        - wait_until:
                condition:
                  lambda: |-
                      return id(stepper1).has_reached_target();
        - lambda: |-          
            id(position).publish_state(id(stepper1).current_position); 
        - delay: 2s
        - lambda: |-            
            id(en_stepper).publish_state(false);
  - platform: template
    name: Stepper Stop
    on_press:
      then:
        - stepper.set_target:
            id: stepper1
            target: !lambda "return id(stepper1).current_position;"
        - lambda: |-          
            id(position).publish_state(id(stepper1).current_position);          
        - delay: 2s
        - lambda: |-            
            id(en_stepper).publish_state(false);


binary_sensor:
  - platform: gpio
    id: stall_guard_sensor
    name: StallGuard
    pin: ${diag_pin}
    on_press:
      then:
        - stepper.set_target:
            id: stepper1
            target: !lambda "return id(stepper1).current_position;"
	- delay: 1s
        - lambda: |-          
            id(position).publish_state(id(stepper1).current_position);
            id(en_stepper).publish_state(false);

sensor:
  - platform: template
    name: Pozice
    id: position
    lambda: |-
      return id(stepper1).current_position;
    update_interval: never

